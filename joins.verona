use "channel-condition.verona"

/* Joins using Channels in Verona
 *
 * Supporting are the Tuple classes and Run interfaces
 *
 * Join pattern are constructed from channels and callbacks,
 * when all the channels required for a callback have a message the callback
 * runs
 */

class Tuple1[A] {
  a: A;
  create(a: A): Tuple1[A] & iso {
    var result = new Tuple1;
    result.a = a;
    result
  }
}

class Tuple2[A, B] {
  a: A;
  b: B;
  create(a: A, b: B): Tuple2[A, B] & iso {
    var result = new Tuple2;
    result.a = a;
    result.b = b;
    result
  }
}

interface Run1[A: iso | imm] { apply(self: mut, a: Cell[A] & mut); }
interface Run2[A: iso | imm, B: iso | imm] { apply(self: mut, a: Cell[A] & mut, b: Cell[B] & mut); }

/* Patterns have a number of channels, when the Do method is called a behaviour
 * that waits for messages on all channels is created. Once the callback has
 * run, the same behaviour is rescheduled.
 */
class Pattern1[A: iso | imm] {
  chan: cown[Channel[A]] & imm;

  create(chan: cown[Channel[A]] & imm): Pattern1[A] & iso {
    var result = new Pattern1;
    result.chan = chan;
    result
  }

  And[B: iso | imm](self: iso, chan: cown[Channel[B]] & imm): Pattern2[A, B] & iso {
    Pattern2.create(self, chan)
  }

  Do(self: iso, run: Run1[A] & iso) {
    when(var ca = Channel.read(self.chan)) {
      (mut-view run).apply(ca);
      self.Do(run);
    }
  }
}

class Pattern2[A: iso | imm, B: iso | imm] {
  chana: cown[Channel[A]] & imm;
  chanb: cown[Channel[B]] & imm;

  create(prev: Pattern1[A] & iso,
         chan: cown[Channel[B]] & imm): Pattern2[A, B] & iso {
    var result = new Pattern2;
    result.chana = prev.chan;
    result.chanb = chan;
    result
  }

  Do(self: iso, run: Run2[A, B] & iso) {
    when(var ca = Channel.read(self.chana),
         var cb = Channel.read(self.chanb)) {
      (mut-view run).apply(ca, cb);
      self.Do(run);
    }
  }
}

/* Utility to start of a new Pattern */
class Join {
  When[T: iso | imm](chan: cown[Channel[T]] & imm) : Pattern1[T] & iso {
    Pattern1.create(chan)
  }
}

/* Task1 writes the message to the continuation channel */
class Task1 {
  create(): Task1 & iso { new Task1 }
  apply(self: mut,
        cont: Cell[cown[Channel[U64Obj & iso]] & imm] & mut,
        m: Cell[U64Obj & iso] & mut) {
    match cont.extract() {
      var c: cown[Channel[U64Obj & iso]] => {
        match m.extract() {
          var o: U64Obj => {
            Channel.write(c, o);
          }
        }
      }
    };
  }
}

/* Task2 writes the messages to the alternate continuation channels */
class Task2 {
  create(): Task2 & iso { new Task2 }

  apply(self: mut,
        c1: Cell[Tuple2[U64Obj & iso, cown[Channel[U64Obj & iso]] & imm] & iso] & mut,
        c2: Cell[Tuple2[U64Obj & iso, cown[Channel[U64Obj & iso]] & imm] & iso] & mut) {
    match c1.extract() {
      var t1: Tuple2[U64Obj & iso, cown[Channel[U64Obj & iso]] & imm] => {
        match c2.extract() {
          var t2: Tuple2[U64Obj & iso, cown[Channel[U64Obj & iso]] & imm] => {
            Builtin.print("rendezvous pattern\n");
          }
        }
      }
    }
  }
}

class Main {
  main() {
    /* create a buffer through the join pattern */
    var put = Channel.create();
    var get = Channel.create();

    ((Join.When(get)).And(put)).Do(Task1.create());

    /* synchronous methods are the desugared operation from the literature
     * the async get message contains the continuation channel to write to
     */
    var cont = Channel.create();
    Channel.write(get, cont);
    Channel.write(put, U64Obj.create(12));

    /* we then use the result from the continuation channel */
    when(var out = Channel.read(cont)) {
      Builtin.print1("got: {:#}\n", out);
    };

    var p1 = Channel.create();
    var p2 = Channel.create();

    // synchronisation is just continuation channels...
    // so give a continuation channel
    var cont1 = Channel.create();
    var cont2 = Channel.create();

    /* Task2 shows the rendezvous pattern, two continuation channels
     * are present at the same time
     */
    ((Join.When(p1)).And(p2)).Do(Task2.create());

    /* setup the two channels to cause the rendezvous */
    when() {
      Channel.write(p1, Tuple2.create(U64Obj.create(12), cont1));
      when(var c = Channel.read(cont1)) {
        Builtin.print1("cont1: {:#}\n", c);
      }
    };

    when() {
      Channel.write(p2, Tuple2.create(U64Obj.create(45), cont2));
      when(var c = Channel.read(cont2)) {
        Builtin.print1("cont2: {:#}\n", c);
      }
    };
  }
}
