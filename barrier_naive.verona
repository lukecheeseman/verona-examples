/* SD, on 21.02.2020
 *The simplest way for barrier synchronization
 * We have 3 participants; and 2 phases:
 * In the before-barrier phase, participants work separately and
 * concurrently.
 * Then they wait until all of them have reached the barrier
 * Then, in the after-barrier phase they again work separately and
 * concurrently.
 * The implementation uses one cown per participant.
 * The main program spawns the pre-barrier phase for each of them
 * given them their cown. Then it when-s on all the cowns, and spawns
 * the after-barrier phase for all of them.   */


class Participant
{
  id: U64 & imm;
  idle : U64 & imm;

  runBeforeBarrier(self: imm)
  {   // this is called while holding a cown
      var j  = self.id;
      var myid = self.id;
      var myidle = self.idle;
      // the following two lines so that some work is done
      var d  = Delay.create( );
      var k = (mut-view d).delayBeforeBarrier(myid,myidle);
      Builtin.print1("---- part {} reached barrier\n", j)
  }

  runAfterBarrier(self: imm)
  {   var j  = self.id;
      var myid = self.id;
      var myidle = self.idle;
      when(){
         // the following two lines so that some work is done
         var d  = Delay.create( );
         var k = (mut-view d).delayAfterBarrier(myid,myidle);
         Builtin.print1("---- part {} is finished\n", j)
       };
  }

  create(i:U64 & imm,idletime: U64 & imm)   : Participant & imm
  {
    var p = new Participant;
    Builtin.print1("created participant {}\n", i);
    p.id = i;
    p.idle=idletime;
    Builtin.freeze(p)
  }
}

/* This creates some work and some output */
class Delay
{

    delayBeforeBarrier(self: mut, id: U64 &imm, i: U64 &imm): U64&imm
        { // self.printpart(id,id);
           Builtin.print1("    part {} before \n", id);
           if (i<3)
               { 200  }
           else
               { var i1=self.delayBeforeBarrier(id,i-1);
                 var i2=self.delayBeforeBarrier(id,i-2);
                 i1  }
        }

    delayAfterBarrier(self: mut, id: U64 &imm, i: U64 &imm): U64&imm
            { // self.printpart(id,id);
               Builtin.print1("    part {} after \n", id);
               if (i<3)
                   { 200  }
               else
                   { var i1=self.delayAfterBarrier(id,i-1);
                     i1  }
            }

    create( ): Delay & iso
      {
        var d = new Delay;
        d
        }

}



class Main
{
  main()
  {
    var c1 = cown.create(new None);
    var c2 = cown.create(new None);
    var c3 = cown.create(new None);

    var p1 = Participant.create(10,4);
    var p2 = Participant.create(30,8);
    var p3 = Participant.create(60,5);

    Builtin.print("\n====== Created three participants ======\n");

     when( c1) { p1.runBeforeBarrier(); };
     when( c2) { p2.runBeforeBarrier(); };
     when( c3) { p3.runBeforeBarrier(); };

    when( c1, c2, c3 ){
      Builtin.print("\n====== All three have reached barrier ======\n");
      when(){  p1.runAfterBarrier( ); };
      when(){  p2.runAfterBarrier( ); };
      when(){  p3.runAfterBarrier( ); }
    }

   }
}
