use "list.verona"

/*
 * Data structure for tracking a request holds an internal promise to be
 * fulfilled and the number of resources requested (_n).
 */
class Request[T] {
  _promise: (Promise[Group[T]] & iso) | (None & imm);
  _n: U64;

  create(promise: Promise[Group[T]] & iso, n: U64): Request[T] & iso {
    var result = new Request;
    result._promise = promise;
    result._n = n;
    result
  }

  fulfill(self: iso, g: Group[T] & iso) {
    match (self._promise = freeze (new None)) {
      var _: None => {}
      var p: Promise[Group[T]] => p.fulfill(g),
    }
  }
}

/*
 * A wrapper around some data so that a resource can be used to fulfill
 * a promise, regardless of the resources capbability
 */
class Resource[T] {
  _data: (T & iso) | (None & imm);

  create(data: T & iso): Resource[T] & iso {
    var result = new Resource;
    result._data = data;
    result
  }

  read(self: mut): (T & iso) | (None & imm) {
    self._data = freeze (new None)
  }

  write(self: mut, data: T & iso): (T & iso) | (None & imm) {
    self._data = data
  }
}

class Group[T] {
  _group: cown[Pool[T]];
  _resources: List[Resource[T]] & iso;

  create(group: cown[Pool[T]]): Group[T] & iso {
    var result = new Group;
    result._group = group;
    result._resources = List.create();
    result
  }

  add(self: mut, resource: Resource[T] & iso) {
    (mut-view (self._resources)).push_back(resource)
  }

  _return_resources(self: mut) {
    match (mut-view (self._resources)).pop_front() {
      var _: None => {} /* finished returning resources */
      var c: Resource[T] => {
        Pool.return(self._group, c);
        self._return_resources();
      }
    }
  }

  /* TODO: only a view of the contents should be provided? */
  get(self: mut): List[Resource[T]] & mut {
    mut-view (self._resources)
  }

  final(self: mut) {
    self._return_resources();
  }
}

class Pool[T] {
  _resources: List[Resource[T]] & iso;
  _requests: List[Request[T]] & iso;

  create(): cown[Pool[T]] {
    var result = new Pool;
    result._resources = List.create();
    result._requests = List.create();
    cown(result)
  }

  add(group: cown[Pool[T]], resource: T & iso) {
    var cell = Resource.create(resource);
    when (group) {
      (mut-view (group._resources)).push_back(cell)
    }
  }

  return(group: cown[Pool[T]], cell: Resource[T] & iso) {
    when (group) {
      (mut-view (group._resources)).push_back(cell)
    };
    Pool._check_requests(group);
  }

  /*
   * collect n resources into the grouper
   */
  _take_n(self: mut, n: U64, grouper: Group[T] & iso): Group[T] & iso {
    if (n > 0) {
      var resource = (mut-view (self._resources)).pop_front();
      match resource {
        var _: None => {} /* impossible */
        var c: Resource[T] => (mut-view grouper).add(c),
      };
      self._take_n(n - 1, grouper)
    } else {
      grouper
    }
  }

  _check_requests(group: cown[Pool[T]]) {
    when (var g = group) {
      match ((mut-view (g._requests)).pop_front()) {
        var _: None => {}
        var r: Request[T] => {
          if (r._n <= ((mut-view (g._resources)).size())) {
            r.fulfill(g._take_n(r._n, Group.create(group)))
          } else {
            (mut-view (g._requests)).push_front(r)
          }
        }
      }
    }
  }

  /*
   * request n resources from pool
   * returning a promise for when resources are available
   */
  request(group: cown[Pool[T]], n: U64): cown[Group[T]] {
    var p = Promise.create();
    var r = (mut-view p).wait_handle();
    when (var g = group) {
      var r = Request.create(p, n);
      (mut-view (g._requests)).push_back(r);
      Pool._check_requests(group);
    };
    r
  }
}

class Main {
  main() {
    var g = Pool.create();
    Pool.add(g, U64Obj.create(1));
    Pool.add(g, U64Obj.create(2));
    Pool.add(g, U64Obj.create(3));

    when (var sub = Pool.request(g, 2)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(g, 1)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(g, 2)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(g, 3)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
      var r = sub.get();
      Builtin.print1("r: {:#}\n", r);
      var e = r.pop_front();
      match e {
        var _: None => Builtin.print("None?\n"),
        var c: Resource[U64Obj & iso] => {
          Builtin.print1("Contents: {:#}\n", (mut-view c).read());
        }
      };
    };

    when (var sub = Pool.request(g, 2)) {
      Builtin.print1("Resources: {:#}\n", sub);
    };
  }
}
