use "list.verona"

/*
 * Data structure for tracking a request holds an internal promise to be
 * fulfilled and the number of resources requested (_n).
 */
class Request[T] {
  _promise: Promise[Group[T]] & iso;
  _n: U64 & imm;

  create(n: U64 & imm): Request[T] & iso {
    var result = new Request;
    result._promise = Promise.create();
    result._n = n;
    result
  }

  await(self: mut): cown[Group[T]] & imm {
    (mut-view (self._promise)).wait_handle()
  }

  /*
   * Fulfill this request by providing a Group[T], this fulfills
   * the waiting promise.
   */
  fulfill(self: iso, g: Group[T] & iso) {
    (self._promise).fulfill(g);
  }
}

/*
 * A wrapper around some data so that a resource can be used to fulfill
 * a promise, regardless of the resource's capbability
 */
class Cell[T] {
  _data: (T & iso) | (None & imm);

  create(data: T & iso): Cell[T] & iso {
    var result = new Cell;
    result._data = data;
    result
  }

 extract(self: mut): (T & iso) | (None & imm) {
    self._data = Builtin.freeze(new None)
  }

  write(self: mut, data: T & iso): (T & iso) | (None & imm) {
    self._data = data
  }
}

class Group[T] {
  _pool: cown[Pool[T]] & imm;
  _resources: List[Cell[T]] & iso;

  create(pool: cown[Pool[T]] & imm,
         resources: List[Cell[T]] & iso): Group[T] & iso {
    var result = new Group;
    result._pool = pool;
    result._resources = resources;
    result
  }

  /* TODO: only a view of the contents should be provided? */
  get(self: mut): List[Cell[T]] & mut {
    mut-view (self._resources)
  }

  _return_resources(self: mut) {
    match (mut-view (self._resources)).pop_front() {
      var _: None => {} /* finished returning resources */
      var c: Cell[T] => {
        Pool.return(self._pool, c);
        self._return_resources();
      }
    }
  }

  /*
   * Finaliser returns the resources in the Group to their
   * original Pool
   */
  final(self: mut) {
    self._return_resources();
  }
}

// SD: can a T belong to more than one pool?
// type system seems to forbid it, since the class Cell
// has a field  "_data: (T & iso) | (None & imm);"
class Pool[T] {
  _resources: List[Cell[T]] & iso;
  _requests: List[Request[T]] & iso;

  create(): cown[Pool[T]] & imm {
    var result = new Pool;
    result._resources = List.create();
    result._requests = List.create();
    cown.create(result)
  }

  add(pool: cown[Pool[T]] & imm, resource: T & iso) {
    var cell = Cell.create(resource);
    when (pool) {
      (mut-view (pool._resources)).push_back(cell)
    }
  }

  return(pool: cown[Pool[T]] & imm, cell: Cell[T] & iso) {
    when (pool) {
      (mut-view (pool._resources)).push_back(cell)
    };
    Pool._check_first_request(pool);
  }

  /*
   * collect n resources into the grouper
   */
  // SD
  // PRE: n<= card(self._resources)
  _take_n(self: mut, n: U64 & imm, rs: List[Cell[T]] & iso)
          : List[Cell[T]] & iso {
    if (n > 0) {
      var resource = (mut-view (self._resources)).pop_front();
      match resource {
        var _: None => {} /* impossible */
        var c: Cell[T] => (mut-view rs).push_back(c),
      };
      self._take_n(n - 1, rs)
    } else {
      rs
    }
  }

  _check_first_request(pool: cown[Pool[T]] & imm) {
    when (var p = pool) {
      match ((mut-view (p._requests)).pop_front()) {
        var _: None => {}
        var r: Request[T] => {
          if (r._n <= ((mut-view (p._resources)).size())) {
            r.fulfill(Group.create(pool, p._take_n(r._n, List.create())))
          } else {
            (mut-view (p._requests)).push_front(r)
          }
        }
      }
    }
  }

  /*
   * request n resources from pool
   * returning a promise of a Group[T] when resources are available.
   */
  request(pool: cown[Pool[T]] & imm, n: U64 & imm): cown[Group[T]] & imm {
    // create a request and schedule a behaviour to add it to the pool,
    // immediately return a handle for the request.
    var request = Request.create(n);
    var handle = (mut-view request).await();
    when (var p = pool) {
      (mut-view (p._requests)).push_back(request);
      Pool._check_first_request(pool);
    };
    handle
  }
}

class Main {
  main() {
    var p = Pool.create();
    Pool.add(p, U64Obj.create(1));
    Pool.add(p, U64Obj.create(2));
    Pool.add(p, U64Obj.create(3));

    when (var sub = Pool.request(p, 2)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    /*
    when (var sub = Pool.request(g, 1)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(g, 2)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(g, 3)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
      var r = sub.get();
      Builtin.print1("r: {:#}\n", r);
      var e = r.pop_front();
      match e {
        var _: None => Builtin.print("None?\n"),
        var c: Resource[U64Obj & iso] => {
          Builtin.print1("Contents: {:#}\n", (mut-view c).read());
        }
      };
    };

    when (var sub = Pool.request(g, 2)) {
      Builtin.print1("Resources: {:#}\n", sub);
    };
    */
  }
}
