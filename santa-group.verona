use "group.verona"

interface Entity {
  sleep(self: mut);
  apply(self: mut);
}

class Reindeer {
  _id: U64 & imm;

  create(id: U64 & imm): Reindeer & iso {
    var result = new Reindeer;
    result._id = id;
    result
  }

  sleep(self: mut) {
    // This should be some sleep
    var id = self._id;
    when() {
      Builtin.print1("Reindeer {:#} is on holiday\n", id);
      var i = 0;
      while (i < 2000000) {
        i = i + 1;
      };
    }
  }

  apply(self: mut) {
    Builtin.print1("Reindeer {:#} is delivering toys\n", self._id);
  }
}

class Elf {
  _id: U64 & imm;

  create(id: U64 & imm): Elf & iso {
    var result = new Elf;
    result._id = id;
    result
  }

  sleep(self: mut) {
    // This should be some sleep
    var id = self._id;
    when() {
      Builtin.print1("Elf {:#} is working\n", id);
      var i = 0;
      while (i < 2000000) {
        i = i + 1;
      };
    }
  }

  apply(self: mut) {
    Builtin.print1("Elf {:#} is meeting in study\n", self._id);
  }
}

class Santa {
  create(): cown[Santa] & imm {
    cown.create(new Santa)
  }

  deliver_toys(self: mut) {
    Builtin.print("Santa is delivering toys\n");
  }

  meet_in_study(self: mut) {
    Builtin.print("Santa is meeting in study\n");
  }
}

class Workshop {
  create() {
    // create santa
    var santa = Santa.create();

    // create the reindeer
    var reindeer = Pool.create();
    var i = 0;
    while (i < 9) {
      i = i + 1;
      Pool.add(reindeer, Cell.create(Reindeer.create(i)));
    };

    // create the elves
    var elves = Pool.create();
    i = 0;
    while (i < 7) {
      i = i + 1;
      Pool.add(elves, Cell.create(Elf.create(i)));
    };

    Builtin.print("Running the workshop\n");

    Workshop.act(santa, reindeer, 9);
    Workshop.act(santa, elves, 3);
  }

  _dispatch_entities[E: Entity](qentity: Queue[Resource[E]] & iso) {
    match (mut-view qentity).remove() {
      var _: None => {}
      var rentity: Resource[E] => {
        var entity = (mut-view rentity).use();
        (mut-view entity).apply();
        when () {
          var entity = (mut-view rentity).use();
          (mut-view entity).sleep();
        };
        Workshop._dispatch_entities(qentity);
      }
    };
  }

  act[E: Entity](santa: cown[Santa] & imm, pool: cown[Pool[E]] & imm,
                 n: U64 & imm) {
    when(santa, var group = Pool.request(pool, n)) {
      Builtin.print("------------------------------------\n");
      // FIXME: horrid inspection of the type parameter
      match(group) {
        var rg: Group[Reindeer & iso] => santa.deliver_toys(),
        var eg: Group[Elf & iso] => santa.meet_in_study(),
      };
      Workshop._dispatch_entities(group.extract());
    };
    when() {
      Workshop.act(santa, pool, n);
    }
  }
}

class Main {
  main() {
    Workshop.create();
  }
}
