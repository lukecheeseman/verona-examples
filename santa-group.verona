use "group.verona"

interface Entity {
  sleep(self: mut);
  apply(self: mut);
}

class Reindeer {
  _id: U64 & imm;

  create(id: U64 & imm): Reindeer & iso {
    var result = new Reindeer;
    result._id = id;
    result
  }

  sleep(self: mut) {
    // This should be some sleep
    Builtin.print1("Reindeer {:#} is on holiday\n", self._id);
    var i = 0;
    while (i < 2000) {
      i = i + 1;
    };
  }

  apply(self: mut) {
    Builtin.print1("Reindeer {:#} is delivering toys\n", self._id);
  }
}

class Elf {
  _id: U64 & imm;

  create(id: U64 & imm): Elf & iso {
    var result = new Elf;
    result._id = id;
    result
  }

  sleep(self: mut) {
    // This should be some sleep
    Builtin.print1("Elf {:#} is working\n", self._id);
    var i = 0;
    while (i < 2000) {
      i = i + 1;
    };
  }

  apply(self: mut) {
    Builtin.print1("Elf {:#} is meeting in study\n", self._id);
  }
}

class Santa {
  create(): cown[Santa] & imm {
    cown.create(new Santa)
  }
}

interface WorkshopAction[E: Entity] {
  apply(self: imm, santa: Santa & mut, entities: Queue[Resource[E]] & iso);
}

class DeliverToys {
  create(): DeliverToys & imm { Builtin.freeze(new DeliverToys) }
  apply(self: imm, santa: Santa & mut,
        entities: Queue[Resource[Reindeer]] & iso) {
    Builtin.print("Santa is meeting in study\n");
    Workshop._dispatch_entities(entities);
  }
}

class MeetInStudy {
  create(): MeetInStudy & imm { Builtin.freeze(new MeetInStudy) }
  apply(self: imm, santa: Santa & mut,
        entities: Queue[Resource[Elf]] & iso)
  {
    Builtin.print("Santa is meeting in study\n");
    Workshop._dispatch_entities(entities);
  }
}

class Workshop {
  create() {
    // create santa
    var santa = Santa.create();

    // create the reindeer
    var reindeer = Pool.create();
    var i = 0;
    while (i < 9) {
      i = i + 1;
      Pool.add(reindeer, Cell.create(Reindeer.create(i)));
    };

    // create the elves
    var elves = Pool.create();
    i = 0;
    while (i < 7) {
      i = i + 1;
      Pool.add(elves, Cell.create(Elf.create(i)));
    };

    Builtin.print("Running the workshop\n");
    Workshop.act(DeliverToys.create(), santa, reindeer, 9);
    Workshop.act(MeetInStudy.create(), santa, elves, 3);
  }

  _dispatch_entities[E: Entity](qentity: Queue[Resource[E]] & iso) {
    match (mut-view qentity).remove() {
      var _: None => {}
      var rentity: Resource[E] => {
        var entity = (mut-view rentity).use();
        (mut-view entity).apply();
        when () {
          var entity = (mut-view rentity).use();
          (mut-view entity).sleep();
        };
        Workshop._dispatch_entities(qentity);
      }
    };
  }

  act[E: Entity](action: WorkshopAction[E] & imm, santa: cown[Santa] & imm,
                 pool: cown[Pool[E]] & imm, n: U64 & imm) {
    when(santa, var group = Pool.request(pool, n)) {
      Builtin.print("------------------------------------\n");
      action.apply(santa, group.extract());
    };
    when() {
      Workshop.act(action, santa, pool, n);
    }
  }
}

class Main {
  main() {
    Workshop.create();
  }
}
