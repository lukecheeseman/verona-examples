/* Example accessing two accounts and transfering money.
 * Demonstrates safe exclusive mutable access, without locking, transaction or two-phase commit
 */
class Account {
  _balance: U64 & imm;
  _frozen: U64 & imm;

  create(opening: U64 & imm): Account & iso {
    var result = new Account;
    result._balance = opening;
    result._frozen = 0;
    result
  }

  balance(self: mut): U64 & imm {
    self._balance
  }

  withdraw(self: mut, amount: U64 & imm) {
    self._balance = self._balance - amount;
  }

  deposit(self: mut, amount: U64 & imm) {
    self._balance = self._balance + amount;
  }

  freeze(self: mut) {
    self._frozen = 1;
  }

  unfreeze(self: mut) {
    self._frozen = 0;
  }

  frozen(self: mut): U64 & imm {
    self._frozen
  }
}

class Main {
  transfer(src: cown[Account] & imm, dst: cown[Account] & imm, amount: U64 & imm) {
    when(src, dst) {
      if (src.frozen() || dst.frozen()) {
        Builtin.print1("tansferring from src to dst failed\n\n", amount);
      } else {
        Builtin.print1("tansferring {:#} from src to dst\n\n", amount);
        src.withdraw(amount);
        dst.deposit(amount);
      }
    }
  }

  main() {
    var src = cown.create(Account.create(500));
    var dst = cown.create(Account.create(300));

    when(src, dst) {
      Builtin.print1("src balance: {:#}\n", src.balance());
      Builtin.print1("dst balance: {:#}\n\n", dst.balance())
    };

    Main.transfer(src, dst, 30);

    when(src, dst) {
      Builtin.print1("src balance: {:#}\n", src.balance());
      Builtin.print1("dst balance: {:#}\n\n", dst.balance())
    };

    // The freeze can move before the previous print, which is fine but
    // it cannot happen after the transaction or the print
    when(src) {
      src.freeze();
      Builtin.print("freezing src\n\n")
    };

    Main.transfer(src, dst, 30);

    when(src, dst) {
      Builtin.print1("src balance: {:#}\n", src.balance());
      Builtin.print1("dst balance: {:#}\n", dst.balance())
    };


  }
}
