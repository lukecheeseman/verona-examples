use "channel-condition.verona"

/* Joins using Channels in Verona
 *
 * Supporting are the Tuple classes and Run interfaces
 *
 * Join pattern are constructed from channels and callbacks,
 * when all the channels required for a callback have a message the callback
 * runs
 */

class Unit {
  create(): None & imm { Builtin.freeze(new None) }
}

class AsyncMessage[A] {
  data: Cell[A] & iso;

  create(data: A & iso): AsyncMessage[A] & iso {
    var result = new AsyncMessage;
    result.data = Cell.create(data);
    result
  }
}

class AsyncChan[S] {
  chan: cown[Channel[AsyncMessage[S]]] & imm;

  create(): cown[AsyncChan[S]] & imm {
    var result = new AsyncChan;
    result.chan = Channel.create();
    cown.create(result)
  }

  apply(chan: cown[AsyncChan[S]] & imm, value: S & iso) {
    when(chan) {
      Channel.write(chan.chan, AsyncMessage.create(value));
    }
  }

  _get(chan: cown[AsyncChan[S]] & imm): cown[AsyncMessage[S]] & imm {
    var p = Promise.create();
    var fut = (mut-view p).wait_handle();
    when(chan) {
      when(var out = Channel.read(chan.chan)) {
        match out.extract() {
          var m: AsyncMessage[S] => p.fulfill(m),
        }
      }
    };
    fut
  }
}

class SyncMessage[S, R] {
  _data: (Cell[S] & iso) | (None & imm);
  _reply: (Promise[Cell[R]] & iso) | (None & imm);

  create(data: S & iso, reply: Promise[Cell[R]] & iso): SyncMessage[S, R] & iso {
    var result = new SyncMessage;
    result._data = Cell.create(data);
    result._reply = reply;
    result
  }

  reply(self: mut, value: R & iso) {
    match (self._reply = Builtin.freeze(new None)) {
      var p: Promise[Cell[R]] => {
        p.fulfill(Cell.create(value));
      }
    }
  }
}

class SyncChan[S, R] {
  chan: cown[Channel[SyncMessage[S, R]]] & imm;

  create(): cown[SyncChan[S, R]] & imm {
    var result = new SyncChan;
    result.chan = Channel.create();
    cown.create(result)
  }

  apply(chan: cown[SyncChan[S, R]] & imm, value: S & iso): cown[Cell[R]] & imm {
    var p = Promise.create();
    var fut = (mut-view p).wait_handle();
    when(chan) {
      var reply = Promise.create();
      var replyfut = (mut-view reply).wait_handle();
      Channel.write(chan.chan, SyncMessage.create(value, reply));
      when(replyfut) {
        p.fulfill(Cell.create(replyfut.extract()));
      }
    };
    fut
  }

  _get(chan: cown[SyncChan[S, R]] & imm): cown[SyncMessage[S, R]] & imm {
    var p = Promise.create();
    var fut = (mut-view p).wait_handle();
    when(chan) {
      when(var out = Channel.read(chan.chan)) {
        match out.extract() {
          var m: SyncMessage[S, R] => {
            p.fulfill(m);
          }
        }
      }
    };
    fut
  }
}

//interface Run1[A: iso | imm] { apply(self: mut, a: Cell[A] & mut); }
//interface Run2[A: iso | imm, B: iso | imm] { apply(self: mut, a: Cell[A] & mut, b: Cell[B] & mut); }


/* Patterns have a number of channels, when the Do method is called a behaviour
 * that waits for messages on all channels is created. Once the callback has
 * run, the same behaviour is rescheduled.
 */
class Pattern1[S, R] {

}
/*
  chan: (cown[AsyncChan[S]] & imm) | (cown[SyncChan[S, R]] & imm);

  create(chan: (cown[AsyncChan[S]] & imm) | (cown[SyncChan[S, R]] & imm)): Pattern1[S, R] & iso {
    var result = new Pattern1;
    result.chan = chan;
    result
  }

  //And[B: iso | imm](self: iso, chan: cown[Channel[B]] & imm): Pattern2[A, B] & iso {
  //  Pattern2.create(self, chan)
  //}

  Do(self: iso, run: Run1[S] & iso) {
  }
}
 */
/*
  Do(self: iso, run: Run1[S] & iso) {
    match self.chan {
      var async: cown[AsyncChan[S]] => {
        when(var m = AsyncChan._get(async)) {
          (mut-view run).apply(m);
          self.Do(run);
        }
      }
      var sync: cown[SyncChan[S, R]] => {
        when(var m = SyncChan._get(sync)) {
        }
      }
    }
  }*/

/*
class Join {
  When[S, R](chan: (cown[AsyncChan[S]] & imm) | (cown[SyncChan[S, R]] & imm)) : Pattern1[S, R] & iso {
    Pattern1.create(chan)
  }
}

class Pattern2[A: iso | imm, B: iso | imm] {
  chana: cown[Channel[A]] & imm;
  chanb: cown[Channel[B]] & imm;

  create(prev: Pattern1[A] & iso,
         chan: cown[Channel[B]] & imm): Pattern2[A, B] & iso {
    var result = new Pattern2;
    result.chana = prev.chan;
    result.chanb = chan;
    result
  }

  Do(self: iso, run: Run2[A, B] & iso) {
    when(var ca = Channel.read(self.chana),
         var cb = Channel.read(self.chanb)) {
      (mut-view run).apply(ca, cb);
      self.Do(run);
    }
  }
}


class Task1 {
  apply(self: mut,
        cont: Cell[cown[Channel[U64Obj & iso]] & imm] & mut,
        m: Cell[U64Obj & iso] & mut) {
    match cont.extract() {
      var c: cown[Channel[U64Obj & iso]] => {
        match m.extract() {
          var o: U64Obj => {
            Channel.write(c, o);
          }
        }
      }
    };
  }
}
*/

class Main {
  main() {
    /* create a buffer through the join pattern */
    var put = AsyncChan.create();
    var get = SyncChan.create();

//    (Join.When(get)).Do(Task0.create());

    AsyncChan.apply(put, U64Obj.create(10));

      /*
    when(var out = SyncChan.apply(get, Unit.create())) {
      match out.extract() {
        var _: None => Builtin.print("Got: None\n"),
        var o: U64Obj => Builtin.print1("Got: {:#}\n", o),
      }
    }*/

  }
}

