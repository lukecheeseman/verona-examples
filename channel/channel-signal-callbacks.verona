use "signal-callbacks.verona"

/* Channel built using a signal variable or signal:
 *
 * A signal object is wrapper on top of a promise, behaviours can be
 * triggered when a codition has been met by when'ing on the cown returned
 * by await. When the the signal vairable is signalled, the current
 * promise is fulfilled and replaced with a new promise. Any behaviours that
 * we waiting for the signal previouslt can now run.
 *
 * A channel is built on top of this by having a channel use a signal
 * variable that any unfulfilled read waits on, when wite happens (changing
 * the state of the channel) all waiting reads are signalled and all try to
 * read values. Any reads that did not succesfully read a value, wait again
 * on the signal variable.
 *
 * This example then uses a single producer and consumer to write and read
 * values into and out of the channel
 */

/* Cell object so that values can be sent around in promises and extracted
 * later without losing iso access to them */
class Cell[T] {
  _data: (T & iso) | (None & imm);

  create(data: (T & iso) | (None & imm)): Cell[T] & iso {
    var result = new Cell;
    result._data = data;
    result
  }

  extract(self: mut): (T & iso) | (None & imm) {
    self._data = Builtin.freeze(new None)
  }

  read(self: mut): (T & iso) | (None & imm) where return in self {
    self._data
  }
}

interface ReadCallback[T] {
  apply(self: mut, value: Cell[T] & iso);
}

class ReadCallbackNode[T] {
  _callback: ReadCallback[T] & iso;

  create(callback: ReadCallback[T] & iso): ReadCallbackNode[T] & iso {
    var result = new ReadCallbackNode;
    result._callback = callback;
    result
  }

  apply(self: iso, value: Cell[T] & iso) {
    (mut-view (self._callback)).apply(value);
  }
}

class CheckQueue[T] {
  _chan: cown[Channel[T]] & imm;
  _node: (ReadCallbackNode[T] & iso) | (None & imm);

  create(chan: cown[Channel[T]] & imm, callback: ReadCallbackNode[T] & iso): CheckQueue[T] & iso {
    var result = new CheckQueue;
    result._chan = chan;
    result._node = callback;
    result
  }

  apply(self: mut) {
    match (self._node = None.create()) {
      var _: None => {} // This can't happen TODO: explain
      var n: ReadCallbackNode[T] => {
        var chan = self._chan;
        when(var c = chan) {
          match (mut-view (c._queue)).remove() {
            var v: Cell[T] => { n.apply(v); }
            var _: None => { (mut-view (c._signal)).await(CheckQueue.create(chan, n)); }
          }
        }
      }
    }
  }
}

class Channel[T] {
  _queue: Queue[Cell[T]] & iso;
  _signal: Signal & iso;

  create(): cown[Channel[T]] & imm {
    var result = new Channel;
    result._queue = Queue.create(0);
    result._signal = Signal.create();
    cown.create(result)
  }

  write(channel: cown[Channel[T]] & imm, value: T & iso) {
    when (var c = channel) {
      (mut-view (c._queue)).add(Cell.create(value));
      (mut-view (c._signal)).signal();
    }
  }

  read(channel: cown[Channel[T]] & imm, callback: ReadCallback[T] & iso) {
    when (var c = channel) {
      var value = (mut-view (c._queue)).remove();
      match (value) {
        var v: Cell[T] => {
          (mut-view callback).apply(v);
        }

        var _: None => {
          (mut-view (c._signal)).await(CheckQueue.create(channel, ReadCallbackNode.create(callback)));
        }
      };
    }
  }
}

class Producer[T: iso] {
  _channel: cown[Channel[T]] & imm;

  create(channel: cown[Channel[T]] & imm): Producer[T] & iso {
    var result = new Producer;
    result._channel = channel;
    result
  }

  produce(self: mut, value: T) {
    Channel.write(self._channel, value);
  }
}

class Consume[T] {
  create(): Consume[T] & iso {
    new Consume
  }

  apply(self: mut, cell: Cell[T] & iso) {
    Builtin.print1("Recieved: {:#}\n", (mut-view cell).read());
  }
}

class Consumer[T] {
  _channel: cown[Channel[T]] & imm;

  create(channel: cown[Channel[T]] & imm): Consumer[T] & iso {
    var result = new Consumer;
    result._channel = channel;
    result
  }

  consume(self: mut) {
    Channel.read(self._channel, Consume.create());
  }
}

/* Create a producer and consumer that share a channel */
class Main {
  main() {
    var channel = Channel.create();

    var p = Producer.create(channel);
    var c = Consumer.create(channel);

    when() {
      (mut-view p).produce(U64Obj.create(0));
      (mut-view p).produce(U64Obj.create(1));
      (mut-view p).produce(U64Obj.create(2));
      (mut-view p).produce(U64Obj.create(3));
    };

    when() {
      (mut-view c).consume();
      (mut-view c).consume();
      (mut-view c).consume();
      (mut-view c).consume();
    };
  }
}