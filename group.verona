use "list.verona"

/*
 * Data structure for tracking a request holds an internal promise to be
 * fulfilled and the number of resources requested (_n).
 */
class Request[T] {
  _promise: Promise[Group[T]] & iso;
  _n: U64 & imm;

  create(n: U64 & imm): Request[T] & iso {
    var result = new Request;
    result._promise = Promise.create();
    result._n = n;
    result
  }

  await(self: mut): cown[Group[T]] & imm {
    (mut-view (self._promise)).wait_handle()
  }

  /*
   * Fulfill this request by providing a Group[T], this fulfills
   * the waiting promise.
   */
  fulfill(self: iso, g: Group[T] & iso) {
    (self._promise).fulfill(g);
  }
}

/*
 * A wrapper around some data so that a resource can be used to fulfill
 * a promise, regardless of the resource's capbability
 */
class Cell[T] {
  _data: T & iso;

  create(data: T & iso): Cell[T] & iso {
    var result = new Cell;
    result._data = data;
    result
  }
}

class Resource[T] {
  _cell: (Cell[T] & iso) | (None & imm);
  _origin: cown[Pool[T]] & imm;

  create(cell: Cell[T] & iso, origin: cown[Pool[T]] & imm): Resource[T] & iso {
    var result = new Resource;
    result._cell = cell;
    result._origin = origin;
    result
  }

  /*
   * Finaliser returns the resource in the Resource to the
   * original Pool
   */
  final(self: mut) {
    match (self._cell = Builtin.freeze(new None)) {
      var _: None => {}
      var c: Cell[T] => Pool.add(self._origin, c),
    }
  }
}

class Group[T] {
  _resources: Queue[Resource[T]] & iso;

  create(resources: Queue[Resource[T]] & iso): Group[T] & iso {
    var result = new Group;
    result._resources = resources;
    result
  }

  extract(self: mut): Queue[Resource[T]] & iso {
    self._resources = Queue.create(0)
  }
}

// SD: can a T belong to more than one pool?
// type system seems to forbid it, since the class Resource
// has a field  "_data: (T & iso) | (None & imm);"
class Pool[T] {
  _resources: Queue[Cell[T]] & iso;
  _requests: Queue[Request[T]] & iso;

  create(): cown[Pool[T]] & imm {
    var result = new Pool;
    result._resources = Queue.create(0);
    result._requests = Queue.create(0);
    cown.create(result)
  }

  add(pool: cown[Pool[T]] & imm, resource: Cell[T] & iso) {
    when (var p = pool) {
      (mut-view (p._resources)).add(resource);
      Pool._check_requests(pool);
    }
  }

  /*
   * take n resources out of the pool and put them into a list
   */
  _take_n(self: mut, n: U64 & imm, pool: cown[Pool[T]] & imm,
          resources: Queue[Resource[T]] & iso)
        : Queue[Resource[T]] & iso {
    if (n > 0) {
      var resource = (mut-view (self._resources)).remove();
      match resource {
        // already checked that there are more than n available resources
        // so the None branch _should_ not be reached.
        var _: None => {}
        var c: Cell[T] => (mut-view resources).add(Resource.create(c, pool)),
      };
      self._take_n(n - 1, pool, resources)
    } else {
      resources
    }
  }

  /*
   * check the first request in the queue, if it can be satisified then
   * fulfill the requests and schedule a behaviour to check the next
   * waiting request.
   */
  _check_requests(pool: cown[Pool[T]] & imm) {
    when (var p = pool) {
      // get the first waiting request
      match ((mut-view (p._requests)).remove()) {
        var _: None => {}
        var r: Request[T] => {
          if (r._n <= ((mut-view (p._resources)).length)) {
            // fulfill it and check the next request
            r.fulfill(Group.create(p._take_n(r._n, pool, Queue.create(0))));
            Pool._check_requests(pool);
          } else {
            // otherwise, push back on to the head of the queue
            (mut-view (p._requests)).add_front(r);
          }
        }
      }
    }
  }

  /*
   * request n resources from pool
   * returning a promise of a Group[T] when resources are available.
   */
  request(pool: cown[Pool[T]] & imm, n: U64 & imm): cown[Group[T]] & imm {
    // create a request and schedule a behaviour to add it to the pool,
    // immediately return a handle for the request.
    var request = Request.create(n);
    var handle = (mut-view request).await();
    when (var p = pool) {
      (mut-view (p._requests)).add(request);
      Pool._check_requests(pool);
    };
    handle
  }
}

class Main {
  main() {
    var p = Pool.create();
    Pool.add(p, Cell.create(U64Obj.create(1)));
    Pool.add(p, Cell.create(U64Obj.create(2)));
    Pool.add(p, Cell.create(U64Obj.create(3)));

    when (var sub = Pool.request(p, 2)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(p, 1)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(p, 2)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    /*
    when (var sub = Pool.request(p, 3)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
      var rs = (mut-view sub).extract();
      match (mut-view rs).remove() {
        var _: None => Builtin.print("None?\n"),
        var r: Resource[U64Obj & iso] => {
          match (mut-view r).extract() {
            var _: None => {}
            var o: U64Obj => {
              Builtin.print1("Contents: {:#}\n", mut-view o);
            }
          };
        }
      }
    };

    when (var sub = Pool.request(p, 3)) {
      Builtin.print1("Resources: {:#}\n", sub);
    };
  */
  }
}
