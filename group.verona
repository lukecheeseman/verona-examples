use "list.verona"

/*
 * Data structure for tracking a request holds an internal promise to be
 * fulfilled and the number of resources requested (_n).
 */
class Request[T] {
  _promise: Promise[Group[T]] & iso;
  _n: U64 & imm;

  create(n: U64 & imm): Request[T] & iso {
    var result = new Request;
    result._promise = Promise.create();
    result._n = n;
    result
  }

  await(self: mut): cown[Group[T]] & imm {
    (mut-view (self._promise)).wait_handle()
  }

  /*
   * Fulfill this request by providing a Group[T], this fulfills
   * the waiting promise.
   */
  fulfill(self: iso, g: Group[T] & iso) {
    (self._promise).fulfill(g);
  }
}

/*
 * A wrapper around some data so that a resource can be used to fulfill
 * a promise, regardless of the resource's capbability
 */
class Cell[T] {
  _data: (T & iso) | (None & imm);

  create(data: T & iso): Cell[T] & iso {
    var result = new Cell;
    result._data = data;
    result
  }

 extract(self: mut): (T & iso) | (None & imm) {
    self._data = Builtin.freeze(new None)
  }
}

class Group[T] {
  _pool: cown[Pool[T]] & imm;
  _resources: Queue[Cell[T]] & iso;

  create(pool: cown[Pool[T]] & imm,
         resources: Queue[Cell[T]] & iso): Group[T] & iso {
    var result = new Group;
    result._pool = pool;
    result._resources = resources;
    result
  }

  /* TODO: only a view of the contents should be provided? */
  get(self: mut): Queue[Cell[T]] & iso {
    self._resources = Queue.create(0)
  }

  /*
   * Finaliser returns the resources in the Group to their
   * original Pool
   */
  final(self: mut) {
    Pool.return(self._pool, self._resources = Queue.create(0));
  }
}

// SD: can a T belong to more than one pool?
// type system seems to forbid it, since the class Cell
// has a field  "_data: (T & iso) | (None & imm);"
class Pool[T] {
  _resources: Queue[Cell[T]] & iso;
  _requests: Queue[Request[T]] & iso;

  create(resources: Queue[Cell[T]] & iso): cown[Pool[T]] & imm {
    var result = new Pool;
    result._resources = resources;
    result._requests = Queue.create(0);
    cown.create(result)
  }

  _return(self: mut, resources: Queue[Cell[T]] & iso) {
    match (mut-view (resources)).remove() {
      var _: None => {} /* finished returning resources */
      var c: Cell[T] => {
        (mut-view (self._resources)).add(c);
        self._return(resources);
      }
    }
  }

  return(pool: cown[Pool[T]] & imm, resources: Queue[Cell[T]] & iso) {
    when (var p = pool) {
      p._return(resources);
      Pool._check_requests(pool);
    }
  }

  /*
   * take n resources out of the pool and put them into a list
   */
  _take_n(self: mut, n: U64 & imm, resources: Queue[Cell[T]] & iso)
          : Queue[Cell[T]] & iso {
    if (n > 0) {
      var resource = (mut-view (self._resources)).remove();
      match resource {
        // already checked that there are more than n available resources
        // so the None branch _should_ not be reached.
        var _: None => {}
        var c: Cell[T] => (mut-view resources).add(c),
      };
      self._take_n(n - 1, resources)
    } else {
      resources
    }
  }

  /*
   * check the first request in the queue, if it can be satisified then
   * fulfill the requests and schedule a behaviour to check the next
   * waiting request.
   */
  _check_requests(pool: cown[Pool[T]] & imm) {
    when (var p = pool) {
      // get the first waiting request
      match ((mut-view (p._requests)).remove()) {
        var _: None => {}
        var r: Request[T] => {
          if (r._n <= ((mut-view (p._resources)).length)) {
            // fulfill it and check the next request
            r.fulfill(Group.create(pool, p._take_n(r._n, Queue.create(0))));
            Pool._check_requests(pool);
          } else {
            // otherwise, push back on to the head of the queue
            (mut-view (p._requests)).add_front(r);
          }
        }
      }
    }
  }

  /*
   * request n resources from pool
   * returning a promise of a Group[T] when resources are available.
   */
  request(pool: cown[Pool[T]] & imm, n: U64 & imm): cown[Group[T]] & imm {
    // create a request and schedule a behaviour to add it to the pool,
    // immediately return a handle for the request.
    var request = Request.create(n);
    var handle = (mut-view request).await();
    when (var p = pool) {
      (mut-view (p._requests)).add(request);
      Pool._check_requests(pool);
    };
    handle
  }
}

class Main {
  main() {
    var resources = Queue.create(0);
    (mut-view resources).add(Cell.create(U64Obj.create(1)));
    (mut-view resources).add(Cell.create(U64Obj.create(2)));
    (mut-view resources).add(Cell.create(U64Obj.create(3)));
    var p = Pool.create(resources);

    when (var sub = Pool.request(p, 2)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(p, 1)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    when (var sub = Pool.request(p, 2)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
    };

    /*
    when (var sub = Pool.request(g, 3)) {
      Builtin.print1("Resources: {:#}\n-----------------------------------\n", sub);
      var r = sub.get();
      Builtin.print1("r: {:#}\n", r);
      var e = r.remove();
      match e {
        var _: None => Builtin.print("None?\n"),
        var c: Resource[U64Obj & iso] => {
          Builtin.print1("Contents: {:#}\n", (mut-view c).read());
        }
      };
    };

    when (var sub = Pool.request(g, 2)) {
      Builtin.print1("Resources: {:#}\n", sub);
    };
    */
  }
}
