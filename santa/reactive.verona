use "../common/list.verona"

class Cell[T] {
  _data: (T & iso) | (None & imm);

  create(data: T & iso): Cell[T] & iso {
    var result = new Cell;
    result._data = data;
    result
  }
}

class Reindeer {}
class Elf {}
class Santa {}

interface Creater[T] { generate(self: imm): T & iso; }
class ReindeerCreater {
  create(): ReindeerCreater & imm { Builtin.freeze(new ReindeerCreater) }
  generate(self: imm): Reindeer & iso { new Reindeer }
}
class ElfCreater {
  create(): ElfCreater & imm { Builtin.freeze(new ElfCreater) }
  generate(self: imm): Elf & iso { new Elf }
}

class Work {
  santa: cown[Santa] & imm;

  reindeer_threshold: U64 & imm;
  waiting_reindeer: cown[Queue[Queue[Cell[Reindeer]]]] & imm;
  reindeer: cown[Queue[Cell[Reindeer]]] & imm;

  elves: cown[Queue[Cell[Elf]]] & imm;
  elf_threshold: U64 & imm;
  waiting_elves: cown[Queue[Queue[Cell[Elf]]]] & imm;

  // Do these recursively as they type check much quicker than iteratively
  take_members[T](group: Queue[Cell[T]] & mut, n: U64 & imm): Queue[Cell[T]] & iso {
    if n > 0 {
      var subgroup = Work.take_members(group, n - 1);
      match group.remove() {
        var _: None => { /* we checked we had enough */ }
        var member: Cell[T] => {
          (mut-view subgroup).add(member);
        }
      };
      subgroup
    } else {
      Queue.create(0)
    }
  }

  add_member[T](self: imm, member: Cell[T] & iso, group: cown[Queue[Cell[T]]] & imm, threshold: U64 & imm, waiting: cown[Queue[Queue[Cell[T]]]] & imm) {
    when(var group = group) {
      group.add(member);
      if group.length >= threshold {
        var subgroup = Work.take_members(group, threshold);
        when(var waiting = waiting) {
          waiting.add(subgroup);
          self.process();
        }
      }
    }
  }

  return_members[T](self: imm, subgroup: Queue[Cell[T]] & iso, group: cown[Queue[Cell[T]]] & imm, threshold: U64 & imm, waiting:  cown[Queue[Queue[Cell[T]]]] & imm) {
    match (mut-view subgroup).remove() {
      var _: None => { /* We're done */ }
      var member: Cell[T] => {
        self.add_member(member, group, threshold, waiting);
        self.return_members(subgroup, group, threshold, waiting);
      }
    }
  }

  process(self: imm) {
    when(var santa = self.santa, var elves = self.waiting_elves, var reindeer = self.waiting_reindeer) {
      match reindeer.remove() { /* prioritise the reindeer */
        var reindeer: Queue[Cell[Reindeer]] => {
          when() {
            Builtin.print("Reindeer and Santa meet to work\n");
            self.return_members(reindeer, self.reindeer, self.reindeer_threshold, self.waiting_reindeer);
          };
          self.process();
        }

        var _: None => {
          match elves.remove() {
            var elves: Queue[Cell[Elf]] => {
              when() {
                Builtin.print("Elves and Santa meet to Work\n");
                self.return_members(elves, self.elves, self.elf_threshold, self.waiting_elves);
              };
              self.process();
            }

            var _: None => { /* there was no work */ }
          }
        }
      }
    }
  }

  create_members[T](self: imm, creater: Creater[T] & imm, n: U64 & imm, group: cown[Queue[Cell[T]]] & imm, threshold: U64 & imm, waiting: cown[Queue[Queue[Cell[T]]]] & imm) {
    if n > 0 {
      self.add_member(Cell.create(creater.generate()), group, threshold, waiting);
      self.create_members(creater, n - 1, group, threshold, waiting);
    }
  }

  create() {
    var result = new Work;

    result.santa = cown.create(new Santa);

    result.reindeer = cown.create(Queue.create(1));
    result.reindeer_threshold = 9;
    result.waiting_reindeer = cown.create(Queue.create(5));

    result.elves = cown.create(Queue.create(0));
    result.elf_threshold = 3;
    result.waiting_elves = cown.create(Queue.create(4));

    // The groups are all set up so freeze everything so we can
    // share the record to where it needs to be referenced
    var work = Builtin.freeze(result);

    work.create_members(ReindeerCreater.create(), work.reindeer_threshold, work.reindeer, work.reindeer_threshold, work.waiting_reindeer);
    work.create_members(ElfCreater.create(), work.elf_threshold, work.elves, work.elf_threshold, work.waiting_elves);
  }
}

class Main {
  main() {
    Work.create();
  }
}