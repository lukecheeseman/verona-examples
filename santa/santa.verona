use "../barrier/barrier-internal-sync.verona"

/*
 * group is the combination of a Semaphore and a Condition variable
 *   - group allows only _count number of callers to join to proceed with exection (fulfilling their promise)
 *   - a caller of full is barrierled once _count number of cals to join have happened
 *   - once reset is called, _count more callers to join can proceed
 */
class Group {
  _count: U64 & imm;
  _reset: U64 & imm;
  _empty: Promise[None] & iso;
  _full: Promise[None] & iso;

  // create Group for count amount
  create(count: U64 & imm): cown[Group] & imm {
    var result = new Group;
    result._count = count;
    result._reset = count;
    result._empty = Promise.create();
    result._full = Promise.create();
    cown.create(result)
  }

  // reset the the group, signalling all processes that are waiting to
  // join the group that the group is empty
  empty(group: cown[Group] & imm) {
    when(group) {
      group._count = group._reset;
      (group._empty = Promise.create()).fulfill(new None);
    }
  }

  // subscribe to get informed when the group is full
  full(group: cown[Group] & imm): cown[None] & imm {
    var p = Promise.create();
    var f = (mut-view p).wait_handle();
    when(group) {
      if (group._count == 0) {
        p.fulfill(new None);
      } else {
        when(var _ = (mut-view (group._full)).wait_handle()) {
          p.fulfill(new None);
        }
      }
    };
    f
  }

  // try to join the group
  //   - if there is space signal that participant and decrement the count
  //   - otherwise, wait for a signal that the group is empty
  _join(group: cown[Group] & imm, signal: Promise[None] & iso) {
    when(var s = group) {
      if (s._count > 0) {
        s._count = s._count - 1;
        signal.fulfill(new None);
        if (s._count == 0) {
          (s._full = Promise.create()).fulfill(new None);
        }
      } else {
        when (var _ = (mut-view (s._empty)).wait_handle()) {
          Group._join(group, signal);
        };
      }
    };
  }

  // try to join the group, getting notified on success
  join(group: cown[Group] & imm): cown[None] & imm {
    var p = Promise.create();
    var f = (mut-view p).wait_handle();
    Group._join(group, p);
    f
  }
}

// An interface for Elf and Reindeer participants
interface Participant {
  work_alone(self: mut);
  work_together(self: mut);
}

// Elves and Reindeer are processes with
//   - working alone and together task
//   - a group that they try to join
//   - synchronisation primitves for starting and finishing the colloborative tasks
class Process {
  _participant: Participant & iso;
  _group: cown[Group] & imm;
  _enter: cown[Barrier] & imm;
  _exit: cown[Barrier] & imm;

  start(participant: Participant & iso, group: cown[Group] & imm,
        enter: cown[Barrier] & imm, exit: cown[Barrier] & imm) {
    var result = new Process;
    result._participant = participant;
    result._group = group;
    result._enter = enter;
    result._exit = exit;
    result._loop();
  }

  // The lifecycle of a participant
  //   - work alone
  //   - try to join the colloborative group
  //   - synchronise on starting the colloborative task
  //   - synchronise on finishing the colloborative task
  //   - repeat
  _loop(self: iso) {
    (mut-view ((mut-view self)._participant)).work_alone();
    when(var _ = Group.join(self._group)) {
      when(var _ = Barrier.wait(self._enter)) {
        (mut-view ((mut-view self)._participant)).work_together();
        when(var _ = Barrier.wait(self._exit)) {
          self._loop();
        }
      }
    }
  }
}

// Elves are either working along are meeting for R&D with Santa
class Elf {
  _id: U64 & imm;

  create(id: U64 & imm): Elf & iso {
    var result = new Elf;
    result._id = id;
    result
  }

  work_alone(self: mut) {
    Builtin.print1("Elf {:#} is working\n", self._id);
  }

  work_together(self: mut) {
    Builtin.print1("Elf {:#} is meeting with Santa\n", self._id);
  }
}

// Reindeer are either on holidate or delviering toys with Santa
class Reindeer {
  _id: U64 & imm;

  create(id: U64 & imm): Reindeer & iso {
    var result = new Reindeer;
    result._id = id;
    result
  }

  work_alone(self: mut) {
    Builtin.print1("Reindeer {:#} is on holiday\n", self._id);
  }

  work_together(self: mut) {
    Builtin.print1("Reindeer {:#} is delivering toys\n", self._id);
  }
}

interface Task { apply(self: mut); }
class MeetElves {
  create(): MeetElves & iso { new MeetElves }
  apply(self: mut) { Builtin.print("Santa is meeting with Elves\n"); }
}
class MeetReindeer {
  create(): MeetReindeer & iso { new MeetReindeer }
  apply(self: mut) { Builtin.print("Santa is delivering Toys\n"); }
}

class Santa {
  //  Santa tries to meet a group as follows:
  //    - waiting for a signal that the group is full
  //    - using a group of one as a semaphore for Santa (enabling only one Santa task)
  //    - sychronising on starting a colloborative task
  //    - syncrhonising on finishing a colloborative task
  //    - emptying the santa group (uping the semaphore and allowing another Santa task)
  //    - creating another behaviour that does the same
  meet_group(santa: cown[Group] & imm, group: cown[Group] & imm,
             enter: cown[Barrier] & imm, exit: cown[Barrier] & imm,
             task: Task & iso) {
    when(var _ = Group.full(group)) {
      // use santa group as a semaphore
      when(var _ = Group.join(santa)) {
        when(var _ = Barrier.wait(enter)) {
          Group.empty(group);
          (mut-view task).apply();
          when(var _ = Barrier.wait(exit)) {
            Group.empty(santa);
            Santa.meet_group(santa, group, enter, exit, task);
          }
        }
      }
    }
  }

  // Create two behaviours
  //   - one tries to meet elves
  //   - one tries to meet reindeer
  start(reindeerback: cown[Group] & imm, harness: cown[Barrier] & imm, unharness: cown[Barrier] & imm,
        elveswaiting: cown[Group] & imm, roomin: cown[Barrier] & imm, roomout: cown[Barrier] & imm) {
    var santa = Group.create(1);
    Santa.meet_group(santa, elveswaiting, roomin, roomout, MeetElves.create());
    Santa.meet_group(santa, reindeerback, harness, unharness, MeetReindeer.create());
  }
}

class Main {
  main() {
    // Create elves synchronisation mechanism
    //   - a group for 3 elves
    //   - start and end barriers for the 3 elves and Santa
    var elveswaiting = Group.create(3);
    var roomin = Barrier.create(4);
    var roomout = Barrier.create(4);

    // Create reindeer synchronisation mechanism
    //   - a group for 9 reindeer
    //   - start and end barriers for the 9 reindeer and Santa
    var reindeerback = Group.create(9);
    var harness = Barrier.create(10);
    var unharness = Barrier.create(10);

    // Start all participants
    Santa.start(reindeerback, harness, unharness, elveswaiting, roomin, roomout);

    Process.start(Elf.create(1), elveswaiting, roomin, roomout);
    Process.start(Elf.create(2), elveswaiting, roomin, roomout);
    Process.start(Elf.create(3), elveswaiting, roomin, roomout);
    Process.start(Elf.create(4), elveswaiting, roomin, roomout);
    Process.start(Elf.create(5), elveswaiting, roomin, roomout);
    Process.start(Elf.create(6), elveswaiting, roomin, roomout);
    Process.start(Elf.create(7), elveswaiting, roomin, roomout);

    Process.start(Reindeer.create(1), reindeerback, harness, unharness);
    Process.start(Reindeer.create(2), reindeerback, harness, unharness);
    Process.start(Reindeer.create(3), reindeerback, harness, unharness);
    Process.start(Reindeer.create(4), reindeerback, harness, unharness);
    Process.start(Reindeer.create(5), reindeerback, harness, unharness);
    Process.start(Reindeer.create(6), reindeerback, harness, unharness);
    Process.start(Reindeer.create(7), reindeerback, harness, unharness);
    Process.start(Reindeer.create(8), reindeerback, harness, unharness);
    Process.start(Reindeer.create(9), reindeerback, harness, unharness);
  }
}
